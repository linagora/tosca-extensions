# If you are using file_column to upload images, you can
# directly process the textual files with Ultraviolet.
# You can find more information at http://ultraviolet.rubyforge.org/index.xhtml
#
# You can control what to do by adding a <tt>:uv</tt> option
# to your options hash. All operations are performed immediately
# after a new file is assigned to the file_column attribute (i.e.,
# when a new file has been uploaded).
#
# == Colorize text
# To colorize the uploaded text according to an UV themes,
# just use the <tt>:theme</tt> option:
#
#    file_column :file, :uv => { :theme => "blackboard" }
#
# If the uploaded file cannot be transformed by UV, file_column will
# to nothing.
#
# The files generated by UV are HTML files. They are named by the original filename
# and the theme name.
#
# If you upload a cvs.diff file, and if you use the blackboard theme
# you will have a cvs.diff.blackboard.html file in the same directory as the cvs.diff file.
#
# <b>Note:</b> You'll need the UV gem extension being installed
# in order to use file_column's uv integration.

module CtfFileColumn
  def self.extended(base)
    class << base
        alias_method :file_column_without_uv, :file_column
        alias_method :file_column, :file_column_with_uv
    end
  end

  def file_column_with_uv(attr, options={})
    # allows to activate uv in an extension model
    return if method_defined? attr

    options_uv = options[:uv]
    if options_uv
      options_uv[:theme] = "active4d" unless options_uv.has_key? :theme
    end
    file_column_without_uv(attr, options)

    if options_uv
      state_method = "#{attr}_state".to_sym
      after_assign_method = "#{attr}_uv_after_assign".to_sym

      define_method after_assign_method do
        if send(state_method).get_content_type =~ /^text\//
          self.send(state_method).transforme_with_uv
        end
      end

      options[:after_upload] ||= []
      options[:after_upload] << after_assign_method
    end
  end
end

module CtfBaseUploadedFile
  def transform_with_uv
    if needs_transform_uv?
      content = ""
      File.open(absolute_path, "r+") { |f| content = f.read }

      possible_mode = Uv.syntax_for_file(absolute_path)

      mode = possible_mode.empty? ? 'plain_text' : possible_mode.first.first
      result = Uv.parse(content, "xhtml", mode, true, options[:uv][:theme])
      path = absolute_path << get_file_suffix
      File.open(path, "w+") { |f| f.write(result) }
      GC.start
    end
  end

  def get_file_suffix
    "." << options[:uv][:theme] << ".html"
  end

  private

  def needs_transform_uv?
    path = absolute_path << get_file_suffix
    options.has_key?(:uv) && !File.exists?(path)
  end
end
